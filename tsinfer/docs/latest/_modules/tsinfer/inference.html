
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tsinfer.inference &#8212; Tsinfer manual</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/tskit-book-theme.css?digest=4e121f05f62280197eeb3e8760a1903920f0778f" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/scripts/tskit-book-theme.js?digest=9a6366feaade5ec470560844be9ff19788eb9b85"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/tsinfer_logo.svg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Tsinfer manual</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../index.html">
                    Welcome to tsinferâ€™s documentation!
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../introduction.html">
   Introduction
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Installation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../installation.html">
   Installation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Tutorial
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../tutorial.html">
   Tutorial
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Inference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../inference.html">
   Inference overview
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Interfaces
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../api.html">
   API Documentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../cli.html">
   Command line interface
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  File Formats
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../file_formats.html">
   File formats
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Miscellaneous
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../development.html">
   Developer documentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../CITATION.html">
   Citing tsinfer
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../CHANGELOG.html">
   Changelog
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            tsinfer undefined
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/tskit-dev/tsinfer"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/tskit-dev/tsinfer/issues/new?title=Issue%20on%20page%20%2F_modules/tsinfer/inference.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for tsinfer.inference</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright (C) 2018-2021 University of Oxford</span>
<span class="c1">#</span>
<span class="c1"># This file is part of tsinfer.</span>
<span class="c1">#</span>
<span class="c1"># tsinfer is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># tsinfer is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with tsinfer.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Central module for high-level inference. The actual implementation of</span>
<span class="sd">of the core tasks like ancestor generation and matching are delegated</span>
<span class="sd">to other modules.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">queue</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">humanize</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tskit</span>

<span class="kn">import</span> <span class="nn">_tsinfer</span>
<span class="kn">import</span> <span class="nn">tsinfer.algorithm</span> <span class="k">as</span> <span class="nn">algorithm</span>
<span class="kn">import</span> <span class="nn">tsinfer.constants</span> <span class="k">as</span> <span class="nn">constants</span>
<span class="kn">import</span> <span class="nn">tsinfer.formats</span> <span class="k">as</span> <span class="nn">formats</span>
<span class="kn">import</span> <span class="nn">tsinfer.progress</span> <span class="k">as</span> <span class="nn">progress</span>
<span class="kn">import</span> <span class="nn">tsinfer.provenance</span> <span class="k">as</span> <span class="nn">provenance</span>
<span class="kn">import</span> <span class="nn">tsinfer.threads</span> <span class="k">as</span> <span class="nn">threads</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="n">sample_data_time_metadata_definition</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Time of an individual from the SampleData file.&quot;</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span>
    <span class="c1"># Defaults aren&#39;t currently used, see</span>
    <span class="c1"># https://github.com/tskit-dev/tskit/issues/1073</span>
    <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">inference_type_metadata_definition</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">(</span>
        <span class="s2">&quot;The type of inference used at this site. This can be one of the following: &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_FULL</span><span class="si">}</span><span class="s2">&#39; for sites which used the standard tsinfer &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;algorithm; &#39;</span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_NONE</span><span class="si">}</span><span class="s2">&#39; for sites containing only missing &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;data or the ancestral state; &#39;</span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_PARSIMONY</span><span class="si">}</span><span class="s2">&#39; for sites &quot;</span>
        <span class="s2">&quot;that used a parsimony algorithm to place mutations based on trees inferred &quot;</span>
        <span class="s2">&quot;from the remaining data.&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
    <span class="s2">&quot;enum&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_NONE</span><span class="p">,</span>
        <span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_FULL</span><span class="p">,</span>
        <span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_PARSIMONY</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">add_to_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">definition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">definition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">definition</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The metadata </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is reserved for use by tsinfer&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">definition</span>
    <span class="k">if</span> <span class="n">required</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;required&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
            <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;required&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;required&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">schema</span>


<span class="k">def</span> <span class="nf">is_pc_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the path compression ancestor flag is set on the specified</span>
<span class="sd">    flags value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_PC_ANCESTOR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">is_srb_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the shared recombination breakpoint flag is set on the</span>
<span class="sd">    specified flags value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_SRB_ANCESTOR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">count_pc_ancestors</span><span class="p">(</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of values in the specified array which have the</span>
<span class="sd">    NODE_IS_PC_ANCESTOR set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">is_pc_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">count_srb_ancestors</span><span class="p">(</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of values in the specified array which have the</span>
<span class="sd">    NODE_IS_SRB_ANCESTOR set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_SRB_ANCESTOR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>


<span class="n">AlleleCounts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;AlleleCounts&quot;</span><span class="p">,</span> <span class="s2">&quot;known ancestral derived&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">allele_counts</span><span class="p">(</span><span class="n">genotypes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return summary counts of the number of different allele types for a genotypes array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_known</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">genotypes</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span><span class="p">)</span>
    <span class="n">n_ancestral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">genotypes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AlleleCounts</span><span class="p">(</span>
        <span class="n">known</span><span class="o">=</span><span class="n">n_known</span><span class="p">,</span> <span class="n">ancestral</span><span class="o">=</span><span class="n">n_ancestral</span><span class="p">,</span> <span class="n">derived</span><span class="o">=</span><span class="n">n_known</span> <span class="o">-</span> <span class="n">n_ancestral</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if this really is a ProgressMonitor, if not, return something usable as one</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">progress</span><span class="o">.</span><span class="n">ProgressMonitor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">progress_monitor</span>
    <span class="k">if</span> <span class="n">progress_monitor</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">progress</span><span class="o">.</span><span class="n">ProgressMonitor</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">progress</span><span class="o">.</span><span class="n">DummyProgressMonitor</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_encode_raw_metadata</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_update_site_metadata</span><span class="p">(</span><span class="n">current_metadata</span><span class="p">,</span> <span class="n">inference_type</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;inference_type&quot;</span><span class="p">:</span> <span class="n">inference_type</span><span class="p">,</span> <span class="o">**</span><span class="n">current_metadata</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">tree_sequence</span><span class="p">,</span> <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    verify(samples, tree_sequence)</span>

<span class="sd">    Verifies that the specified sample data and tree sequence files encode the</span>
<span class="sd">    same data.</span>

<span class="sd">    :param SampleData samples: The input :class:`SampleData` instance</span>
<span class="sd">        representing the observed data that we wish to compare to.</span>
<span class="sd">    :param TreeSequence tree_sequence: The input :class:`tskit.TreeSequence`</span>
<span class="sd">        instance an encoding of the specified samples that we wish to verify.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_sites</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;numbers of sites not equal&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;numbers of samples not equal&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sequence lengths not equal&quot;</span><span class="p">)</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;verify&quot;</span><span class="p">,</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">sample_data</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span><span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">variants</span><span class="p">()</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;site positions not equal: </span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># First (ancestral) allele should always be the same</span>
        <span class="k">if</span> <span class="n">var1</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ancestral allele not equal at site </span><span class="si">{</span><span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">var1</span><span class="o">.</span><span class="n">alleles</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">alleles</span><span class="p">:</span>
            <span class="c1"># Alleles may be in a different order, or even present/absent if not in the</span>
            <span class="c1"># genotype matrix so we need to explicitly compare the decoded values (slow)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span><span class="p">)):</span>
                <span class="c1"># We don&#39;t expect missingness in a tsinfer generated tree sequence</span>
                <span class="k">assert</span> <span class="n">g2</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
                <span class="k">if</span> <span class="n">g1</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span> <span class="ow">and</span> <span class="n">var1</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="n">g1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="n">g2</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Alleles for sample </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> not equal at site </span><span class="si">{</span><span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">var1</span><span class="o">.</span><span class="n">genotypes</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span><span class="p">)</span>
            <span class="n">missing_mask</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
            <span class="n">g2</span><span class="p">[</span><span class="n">missing_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Genotypes not equal at site </span><span class="si">{</span><span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
    <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">check_sample_indexes</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks that the specified sample indexes are valid for the specified</span>
<span class="sd">    sample data file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sample_data</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must supply at least one sample to match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indexes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indexes</span> <span class="o">&gt;=</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">num_samples</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample index out of bounds&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indexes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample indexes must be in increasing order&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">indexes</span>


<div class="viewcode-block" id="infer"><a class="viewcode-back" href="../../api.html#tsinfer.infer">[docs]</a><span class="k">def</span> <span class="nf">infer</span><span class="p">(</span>
    <span class="n">sample_data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exclude_positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">post_process</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">time_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">simplify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Deprecated</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    infer(sample_data, *, recombination_rate=None, mismatch_ratio=None,\</span>
<span class="sd">            path_compression=True, exclude_positions=None, post_process=None,\</span>
<span class="sd">            num_threads=0)</span>

<span class="sd">    Runs the full :ref:`inference pipeline &lt;sec_inference&gt;` on the specified</span>
<span class="sd">    :class:`SampleData` instance and returns the inferred</span>
<span class="sd">    :class:`tskit.TreeSequence`.  See</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`</span>
<span class="sd">    in the documentation for details of ``recombination_rate``, ``mismatch_ratio``</span>
<span class="sd">    and ``path_compression``.</span>

<span class="sd">    .. note::</span>
<span class="sd">        For finer grained control over inference, for example to set different mismatch</span>
<span class="sd">        ratios when matching ancestors versus samples, run</span>
<span class="sd">        :func:`tsinfer.generate_ancestors`, :func:`tsinfer.match_ancestors` and</span>
<span class="sd">        :func:`tsinfer.match_samples` separately.</span>

<span class="sd">    :param SampleData sample_data: The input :class:`SampleData` instance</span>
<span class="sd">        representing the observed data that we wish to make inferences from.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant rate</span>
<span class="sd">        :math:`\\rho` per unit length of genome, or an :class:`msprime.RateMap`</span>
<span class="sd">        object. This is used to calculate the probability of recombination between</span>
<span class="sd">        adjacent sites. If ``None``, all matching conflicts are resolved by</span>
<span class="sd">        recombination and all inference sites will have a single mutation</span>
<span class="sd">        (equivalent to mismatch_ratio near zero)</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the median</span>
<span class="sd">        probability of recombination between adjacent sites: can only be used if a</span>
<span class="sd">        recombination rate has been set (default: 1)</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical</span>
<span class="sd">        paths (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :param bool post_process: Whether to run the :func:`post_process` method on the</span>
<span class="sd">        the tree sequence which, among other things, removes ancestral material that</span>
<span class="sd">        does not end up in the current samples (if not specified, defaults to ``True``)</span>
<span class="sd">    :param array_like exclude_positions: A list of site positions to exclude</span>
<span class="sd">        for full inference. Sites with these positions will not be used to generate</span>
<span class="sd">        ancestors, and not used during the copying process. Any such sites that</span>
<span class="sd">        exist in the sample data file will be included in the trees after the</span>
<span class="sd">        main inference process using parsimony. The list does not need to be</span>
<span class="sd">        in to be in any particular order, and can include site positions that</span>
<span class="sd">        are not present in the sample data file.</span>
<span class="sd">    :param int num_threads: The number of worker threads to use in parallelised</span>
<span class="sd">        sections of the algorithm. If &lt;= 0, do not spawn any threads and</span>
<span class="sd">        use simpler sequential algorithms (default).</span>
<span class="sd">    :param bool simplify: When post_processing, only simplify the tree sequence.</span>
<span class="sd">        deprecated but retained for backwards compatibility (default: ``None``).</span>
<span class="sd">    :return: The :class:`tskit.TreeSequence` object inferred from the</span>
<span class="sd">        input sample data.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span>
        <span class="n">progress_monitor</span><span class="p">,</span>
        <span class="n">generate_ancestors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">match_ancestors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">match_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ancestor_data</span> <span class="o">=</span> <span class="n">generate_ancestors</span><span class="p">(</span>
        <span class="n">sample_data</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
        <span class="n">exclude_positions</span><span class="o">=</span><span class="n">exclude_positions</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ancestors_ts</span> <span class="o">=</span> <span class="n">match_ancestors</span><span class="p">(</span>
        <span class="n">sample_data</span><span class="p">,</span>
        <span class="n">ancestor_data</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
        <span class="n">time_units</span><span class="o">=</span><span class="n">time_units</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">inferred_ts</span> <span class="o">=</span> <span class="n">match_samples</span><span class="p">(</span>
        <span class="n">sample_data</span><span class="p">,</span>
        <span class="n">ancestors_ts</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
        <span class="n">post_process</span><span class="o">=</span><span class="n">post_process</span><span class="p">,</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
        <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">inferred_ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">command</span><span class="o">=</span><span class="s2">&quot;infer&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
        <span class="n">inferred_ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">inferred_ts</span></div>


<div class="viewcode-block" id="generate_ancestors"><a class="viewcode-back" href="../../api.html#tsinfer.generate_ancestors">[docs]</a><span class="k">def</span> <span class="nf">generate_ancestors</span><span class="p">(</span>
    <span class="n">sample_data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generate_ancestors(sample_data, *, path=None, exclude_positions=None,\</span>
<span class="sd">        num_threads=0, **kwargs)</span>

<span class="sd">    Runs the ancestor generation :ref:`algorithm &lt;sec_inference_generate_ancestors&gt;`</span>
<span class="sd">    on the specified :class:`SampleData` instance and returns the resulting</span>
<span class="sd">    :class:`AncestorData` instance. If you wish to store generated ancestors</span>
<span class="sd">    persistently on file you must pass the ``path`` keyword argument to this</span>
<span class="sd">    function. For example,</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        ancestor_data = tsinfer.generate_ancestors(sample_data, path=&quot;mydata.ancestors&quot;)</span>

<span class="sd">    Other keyword arguments are passed to the :class:`AncestorData` constructor,</span>
<span class="sd">    which may be used to control the storage properties of the generated file.</span>

<span class="sd">    :param SampleData sample_data: The :class:`SampleData` instance that we are</span>
<span class="sd">        genering putative ancestors from.</span>
<span class="sd">    :param str path: The path of the file to store the sample data. If None,</span>
<span class="sd">        the information is stored in memory and not persistent.</span>
<span class="sd">    :param array_like exclude_positions: A list of site positions to exclude</span>
<span class="sd">        for full inference. Sites with these positions will not be used to generate</span>
<span class="sd">        ancestors, and not used during the copying process. The list does not</span>
<span class="sd">        need be in any particular order.</span>
<span class="sd">    :param int num_threads: The number of worker threads to use. If &lt; 1, use a</span>
<span class="sd">        simpler synchronous algorithm.</span>
<span class="sd">    :return: The inferred ancestors stored in an :class:`AncestorData` instance.</span>
<span class="sd">    :rtype: AncestorData</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sample_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">sample_data</span><span class="o">.</span><span class="n">sites_time</span><span class="p">[:]))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
        <span class="n">tskit</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="n">sample_data</span><span class="o">.</span><span class="n">sites_time</span><span class="p">[:])</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot generate ancestors from a sample_data instance that mixes user-&quot;</span>
            <span class="s2">&quot;specified times with times-as-frequencies. To explicitly set an undefined&quot;</span>
            <span class="s2">&quot;time for a site, permanently excluding it from inference, set it to np.nan.&quot;</span>
        <span class="p">)</span>
    <span class="k">with</span> <span class="n">formats</span><span class="o">.</span><span class="n">AncestorData</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">ancestor_data</span><span class="p">:</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="n">AncestorsGenerator</span><span class="p">(</span>
            <span class="n">sample_data</span><span class="p">,</span>
            <span class="n">ancestor_data</span><span class="p">,</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">generator</span><span class="o">.</span><span class="n">add_sites</span><span class="p">(</span><span class="n">exclude_positions</span><span class="p">)</span>
        <span class="n">generator</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="n">ancestor_data</span><span class="o">.</span><span class="n">record_provenance</span><span class="p">(</span><span class="s2">&quot;generate_ancestors&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ancestor_data</span></div>


<div class="viewcode-block" id="match_ancestors"><a class="viewcode-back" href="../../api.html#tsinfer.match_ancestors">[docs]</a><span class="k">def</span> <span class="nf">match_ancestors</span><span class="p">(</span>
    <span class="n">sample_data</span><span class="p">,</span>
    <span class="n">ancestor_data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">time_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_ancestors(sample_data, ancestor_data, *, recombination_rate=None,\</span>
<span class="sd">        mismatch_ratio=None, path_compression=True, num_threads=0)</span>

<span class="sd">    Run the ancestor matching :ref:`algorithm &lt;sec_inference_match_ancestors&gt;`</span>
<span class="sd">    on the specified :class:`SampleData` and :class:`AncestorData` instances,</span>
<span class="sd">    returning the resulting :class:`tskit.TreeSequence` representing the</span>
<span class="sd">    complete ancestry of the putative ancestors. See</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`</span>
<span class="sd">    in the documentation for details of ``recombination_rate``, ``mismatch_ratio``</span>
<span class="sd">    and ``path_compression``.</span>

<span class="sd">    :param SampleData sample_data: The :class:`SampleData` instance</span>
<span class="sd">        representing the input data.</span>
<span class="sd">    :param AncestorData ancestor_data: The :class:`AncestorData` instance</span>
<span class="sd">        representing the set of ancestral haplotypes for which we are finding</span>
<span class="sd">        a history.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant rate</span>
<span class="sd">        :math:`\\rho` per unit length of genome, or an :class:`msprime.RateMap`</span>
<span class="sd">        object. This is used to calculate the probability of recombination between</span>
<span class="sd">        adjacent sites. If ``None``, all matching conflicts are resolved by</span>
<span class="sd">        recombination and all inference sites will have a single mutation</span>
<span class="sd">        (equivalent to mismatch_ratio near zero)</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the median</span>
<span class="sd">        probability of recombination between adjacent sites: can only be used if a</span>
<span class="sd">        recombination rate has been set (default: 1)</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical</span>
<span class="sd">        paths (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :param int num_threads: The number of match worker threads to use. If</span>
<span class="sd">        this is &lt;= 0 then a simpler sequential algorithm is used (default).</span>
<span class="sd">    :return: The ancestors tree sequence representing the inferred history</span>
<span class="sd">        of the set of ancestors.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">     &quot;&quot;&quot;</span>
    <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">match_ancestors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sample_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
    <span class="n">ancestor_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>

    <span class="n">matcher</span> <span class="o">=</span> <span class="n">AncestorMatcher</span><span class="p">(</span>
        <span class="n">sample_data</span><span class="p">,</span>
        <span class="n">ancestor_data</span><span class="p">,</span>
        <span class="n">time_units</span><span class="o">=</span><span class="n">time_units</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">recombination</span><span class="o">=</span><span class="n">recombination</span><span class="p">,</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
        <span class="n">mismatch</span><span class="o">=</span><span class="n">mismatch</span><span class="p">,</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
        <span class="n">extended_checks</span><span class="o">=</span><span class="n">extended_checks</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">match_ancestors</span><span class="p">()</span>
    <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">ancestor_data</span><span class="o">.</span><span class="n">provenances</span><span class="p">():</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span>
            <span class="n">command</span><span class="o">=</span><span class="s2">&quot;match_ancestors&quot;</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;uuid&quot;</span><span class="p">:</span> <span class="n">ancestor_data</span><span class="o">.</span><span class="n">uuid</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ts</span></div>


<div class="viewcode-block" id="augment_ancestors"><a class="viewcode-back" href="../../api.html#tsinfer.augment_ancestors">[docs]</a><span class="k">def</span> <span class="nf">augment_ancestors</span><span class="p">(</span>
    <span class="n">sample_data</span><span class="p">,</span>
    <span class="n">ancestors_ts</span><span class="p">,</span>
    <span class="n">indexes</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    augment_ancestors(sample_data, ancestors_ts, indexes, *, recombination_rate=None,\</span>
<span class="sd">        mismatch_ratio=None, path_compression=True, num_threads=0)</span>

<span class="sd">    Runs the sample matching :ref:`algorithm &lt;sec_inference_match_samples&gt;`</span>
<span class="sd">    on the specified :class:`SampleData` instance and ancestors tree sequence,</span>
<span class="sd">    for the specified subset of sample indexes, returning the</span>
<span class="sd">    :class:`tskit.TreeSequence` instance including these samples. This</span>
<span class="sd">    tree sequence can then be used as an ancestors tree sequence for subsequent</span>
<span class="sd">    matching against all samples.  See</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`</span>
<span class="sd">    in the documentation for details of ``recombination_rate``, ``mismatch_ratio``</span>
<span class="sd">    and ``path_compression``.</span>

<span class="sd">    :param SampleData sample_data: The :class:`SampleData` instance</span>
<span class="sd">        representing the input data.</span>
<span class="sd">    :param tskit.TreeSequence ancestors_ts: The</span>
<span class="sd">        :class:`tskit.TreeSequence` instance representing the inferred</span>
<span class="sd">        history among ancestral ancestral haplotypes.</span>
<span class="sd">    :param array indexes: The sample indexes to insert into the ancestors</span>
<span class="sd">        tree sequence, in increasing order.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant rate</span>
<span class="sd">        :math:`\\rho` per unit length of genome, or an :class:`msprime.RateMap`</span>
<span class="sd">        object. This is used to calculate the probability of recombination between</span>
<span class="sd">        adjacent sites. If ``None``, all matching conflicts are resolved by</span>
<span class="sd">        recombination and all inference sites will have a single mutation</span>
<span class="sd">        (equivalent to mismatch_ratio near zero)</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the median</span>
<span class="sd">        probability of recombination between adjacent sites: can only be used if a</span>
<span class="sd">        recombination rate has been set (default: 1)</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical</span>
<span class="sd">        paths (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :param int num_threads: The number of match worker threads to use. If</span>
<span class="sd">        this is &lt;= 0 then a simpler sequential algorithm is used (default).</span>
<span class="sd">    :return: The specified ancestors tree sequence augmented with copying</span>
<span class="sd">        paths for the specified sample.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sample_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
    <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">augment_ancestors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="n">SampleMatcher</span><span class="p">(</span>
        <span class="n">sample_data</span><span class="p">,</span>
        <span class="n">ancestors_ts</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
        <span class="n">recombination</span><span class="o">=</span><span class="n">recombination</span><span class="p">,</span>
        <span class="n">mismatch</span><span class="o">=</span><span class="n">mismatch</span><span class="p">,</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
        <span class="n">extended_checks</span><span class="o">=</span><span class="n">extended_checks</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">sample_indexes</span> <span class="o">=</span> <span class="n">check_sample_indexes</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
    <span class="n">sample_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sample_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span>
    <span class="n">manager</span><span class="o">.</span><span class="n">match_samples</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">get_augmented_ancestors_tree_sequence</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">command</span><span class="o">=</span><span class="s2">&quot;augment_ancestors&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ts</span></div>


<div class="viewcode-block" id="match_samples"><a class="viewcode-back" href="../../api.html#tsinfer.match_samples">[docs]</a><span class="k">def</span> <span class="nf">match_samples</span><span class="p">(</span>
    <span class="n">sample_data</span><span class="p">,</span>
    <span class="n">ancestors_ts</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">post_process</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">force_sample_times</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">simplify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># deprecated</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_samples(sample_data, ancestors_ts, *, recombination_rate=None,\</span>
<span class="sd">        mismatch_ratio=None, path_compression=True, post_process=None,\</span>
<span class="sd">        indexes=None, force_sample_times=False, num_threads=0)</span>

<span class="sd">    Runs the sample matching :ref:`algorithm &lt;sec_inference_match_samples&gt;`</span>
<span class="sd">    on the specified :class:`SampleData` instance and ancestors tree sequence,</span>
<span class="sd">    returning the final :class:`tskit.TreeSequence` instance containing</span>
<span class="sd">    the full inferred history for all samples and sites. See</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`</span>
<span class="sd">    in the documentation for details of ``recombination_rate``, ``mismatch_ratio``</span>
<span class="sd">    and ``path_compression``.</span>

<span class="sd">    :param SampleData sample_data: The :class:`SampleData` instance</span>
<span class="sd">        representing the input data.</span>
<span class="sd">    :param tskit.TreeSequence ancestors_ts: The</span>
<span class="sd">        :class:`tskit.TreeSequence` instance representing the inferred</span>
<span class="sd">        history among ancestral ancestral haplotypes.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant rate</span>
<span class="sd">        :math:`\\rho` per unit length of genome, or an :class:`msprime.RateMap`</span>
<span class="sd">        object. This is used to calculate the probability of recombination between</span>
<span class="sd">        adjacent sites. If ``None``, all matching conflicts are resolved by</span>
<span class="sd">        recombination and all inference sites will have a single mutation</span>
<span class="sd">        (equivalent to mismatch_ratio near zero)</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the median</span>
<span class="sd">        probability of recombination between adjacent sites: can only be used if a</span>
<span class="sd">        recombination rate has been set (default: 1)</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical</span>
<span class="sd">        paths (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :param array_like indexes: An array of indexes into the sample_data file of</span>
<span class="sd">        the samples to match (in increasing order) or None for all samples.</span>
<span class="sd">    :param bool post_process: Whether to run the :func:`post_process` method on the</span>
<span class="sd">        the tree sequence which, among other things, removes ancestral material that</span>
<span class="sd">        does not end up in the current samples (if not specified, defaults to ``True``)</span>
<span class="sd">    :param bool force_sample_times: After matching, should an attempt be made to</span>
<span class="sd">        adjust the time of &quot;historical samples&quot; (those associated with an individual</span>
<span class="sd">        having a non-zero time) such that the sample nodes in the tree sequence</span>
<span class="sd">        appear at the time of the individual with which they are associated.</span>
<span class="sd">    :param int num_threads: The number of match worker threads to use. If</span>
<span class="sd">        this is &lt;= 0 then a simpler sequential algorithm is used (default).</span>
<span class="sd">    :param bool simplify: Treated as an alias for ``post_process``, deprecated but</span>
<span class="sd">        currently retained for backwards compatibility if set to ``False``.</span>

<span class="sd">    :return: The tree sequence representing the inferred history</span>
<span class="sd">        of the sample.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">simplify_only</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># if true, carry out &quot;old&quot; (deprecated) simplify behaviour</span>
    <span class="k">if</span> <span class="n">simplify</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">post_process</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">post_process</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">post_process</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t specify both `simplify` and `post_process`&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;The `simplify` parameter is deprecated in favour of `post_process`&quot;</span>
                <span class="p">)</span>
                <span class="n">simplify_only</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">post_process</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">post_process</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">sample_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
    <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">match_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="n">SampleMatcher</span><span class="p">(</span>
        <span class="n">sample_data</span><span class="p">,</span>
        <span class="n">ancestors_ts</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
        <span class="n">recombination</span><span class="o">=</span><span class="n">recombination</span><span class="p">,</span>
        <span class="n">mismatch</span><span class="o">=</span><span class="n">mismatch</span><span class="p">,</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
        <span class="n">extended_checks</span><span class="o">=</span><span class="n">extended_checks</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">sample_indexes</span> <span class="o">=</span> <span class="n">check_sample_indexes</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
    <span class="n">sample_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">sample_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">force_sample_times</span><span class="p">:</span>
        <span class="n">individuals</span> <span class="o">=</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:][</span><span class="n">sample_indexes</span><span class="p">]</span>
        <span class="c1"># By construction all samples in an sd file have an individual: but check anyway</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">individuals</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sample_times</span> <span class="o">=</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[:][</span><span class="n">individuals</span><span class="p">]</span>

        <span class="c1"># Here we might want to re-order sample_indexes and sample_times</span>
        <span class="c1"># so that any historical ones come first, any we bomb out early if they conflict</span>
        <span class="c1"># but that would mean re-ordering the sample nodes in the final ts, and</span>
        <span class="c1"># we sometimes assume they are in the same order as in the file</span>

    <span class="n">manager</span><span class="o">.</span><span class="n">match_samples</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">post_process</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">_post_process</span><span class="p">(</span>
            <span class="n">ts</span><span class="p">,</span> <span class="n">warn_if_unexpected_format</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify_only</span><span class="o">=</span><span class="n">simplify_only</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="c1"># We don&#39;t have a source here because tree sequence files don&#39;t have a UUID yet.</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">command</span><span class="o">=</span><span class="s2">&quot;match_samples&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ts</span></div>


<span class="k">def</span> <span class="nf">insert_missing_sites</span><span class="p">(</span>
    <span class="n">sample_data</span><span class="p">,</span> <span class="n">tree_sequence</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sample_id_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new tree sequence containing extra sites that are present in a</span>
<span class="sd">    :class:`SampleData` instance but are missing from a corresponding tree sequence.</span>
<span class="sd">    At each newly inserted site, mutations are overlaid parsimoneously, using</span>
<span class="sd">    :meth:`tskit.Tree.map_mutations`,</span>
<span class="sd">    such that the realised variation at that site corresponds to the allelic</span>
<span class="sd">    distribution seen in the sample_data file. Sites that have mutations overlaid</span>
<span class="sd">    in this way can be identified in the output tree sequence as their</span>
<span class="sd">    :ref:`metadata&lt;tskit.sec_metadata_definition&gt;` will contain a key named</span>
<span class="sd">    ``inference`` set to ``tsinfer.INFERENCE_PARSIMONY``. Newly inserted sites</span>
<span class="sd">    that do not require mutations will have this set to `tsinfer.INFERENCE_NONE`</span>
<span class="sd">    instead. Sites in ``sample_data`` that already exist in the tree sequence are</span>
<span class="sd">    left untouched.</span>

<span class="sd">    By default, sample 0 in ``sample_data`` is assumed to correspond to the first</span>
<span class="sd">    sample node in the input tree sequence (i.e. ``tree_sequence.samples()[0]``),</span>
<span class="sd">    sample 1 to the second sample node, and so on. If this is not the case, a map</span>
<span class="sd">    can be provided, which specifies the sample ids in ``sample_data`` that</span>
<span class="sd">    correspond to the sample nodes in the tree sequence. This also allows the use</span>
<span class="sd">    of :class:`SampleData` instances that contain samples in addition to those</span>
<span class="sd">    in the original tree sequence.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Sample states observed as missing in the input ``sample_data`` need</span>
<span class="sd">        not correspond to samples whose nodes are actually &quot;missing&quot; (i.e.</span>
<span class="sd">        :ref:`isolated&lt;tskit.sec_data_model_missing_data&gt;`) in the input tree</span>
<span class="sd">        sequence. In this case, the allelic state of the sample in the returned</span>
<span class="sd">        tree sequence will be imputed to the most parsimonious state.</span>

<span class="sd">    .. note::</span>
<span class="sd">        If the ancestral state at a site is unknown (i.e. ``tskit.MISSING_DATA``),</span>
<span class="sd">        it will be inferred by parsimony. If it is unknown and all sample data</span>
<span class="sd">        is missing at that site, the site will be created with an ancestral state</span>
<span class="sd">        set to the empty string.</span>

<span class="sd">    :param SampleData sample_data: The :class:`SampleData` instance</span>
<span class="sd">        containing some sites that are not in the input tree sequence.</span>
<span class="sd">    :param tskit.TreeSequence tree_sequence: The input :class:`tskit.TreeSequence`</span>
<span class="sd">        whose sample nodes correspond to a set of samples in the sample_data.</span>
<span class="sd">    :param sample_id_map array: An array of length `tree_sequence.num_samples`</span>
<span class="sd">        specifying the indexes of samples in the sample_data file that correspond</span>
<span class="sd">        to sample nodes ``0..(num_samples-1)`` in the tree sequence. If None,</span>
<span class="sd">        assume that all the samples in sample_data correspond to the sample nodes</span>
<span class="sd">        in the tree sequence, and are in the same order.</span>
<span class="sd">    :return: The input tree sequence with additional sites and mutations.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;sample_data and tree_sequence must have the same sequence length&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_id_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sample_id_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">sample_data</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_id_map</span><span class="p">)</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;You must specify the same number of samples in sample_data &quot;</span>
            <span class="s2">&quot;as in the tree_sequence&quot;</span>
        <span class="p">)</span>
    <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">)</span>
    <span class="n">tables</span> <span class="o">=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
    <span class="n">trees</span> <span class="o">=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">trees</span><span class="p">()</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:]</span>
    <span class="n">new_sd_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">schema</span>

    <span class="c1"># Create new sites and add the mutations</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ms_extra_sites&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sd_sites</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span><span class="n">sites</span><span class="o">=</span><span class="n">new_sd_sites</span><span class="p">,</span> <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">site</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">position</span>
        <span class="n">anc_state</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">ancestral_state</span>
        <span class="n">anc_value</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># variant(recode_ancestral=True) always has 0 as the anc index</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">[</span><span class="n">sample_id_map</span><span class="p">]</span>
        <span class="c1"># We can&#39;t perform parsimony inference if all sites are missing, and there&#39;s no</span>
        <span class="c1"># point if all non-missing sites are the ancestral state, so skip these cases</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">G</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span><span class="p">,</span> <span class="n">G</span> <span class="o">==</span> <span class="n">anc_value</span><span class="p">)):</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">_update_site_metadata</span><span class="p">(</span>
                <span class="n">site</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">inference_type</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_NONE</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">ancestral_state</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">anc_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anc_state</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
            <span class="n">anc_state</span><span class="p">,</span> <span class="n">mapped_mutations</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">map_mutations</span><span class="p">(</span>
                <span class="n">G</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span> <span class="n">ancestral_state</span><span class="o">=</span><span class="n">anc_state</span>
            <span class="p">)</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">_update_site_metadata</span><span class="p">(</span>
                <span class="n">site</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">inference_type</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_PARSIMONY</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">new_site_id</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">ancestral_state</span><span class="o">=</span><span class="n">anc_state</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">mut_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mutation</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapped_mutations</span><span class="p">):</span>
                <span class="n">mut_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                    <span class="n">site</span><span class="o">=</span><span class="n">new_site_id</span><span class="p">,</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">mutation</span><span class="o">.</span><span class="n">node</span><span class="p">,</span>
                    <span class="n">derived_state</span><span class="o">=</span><span class="n">mutation</span><span class="o">.</span><span class="n">derived_state</span><span class="p">,</span>
                    <span class="n">parent</span><span class="o">=</span><span class="n">mut_map</span><span class="p">[</span><span class="n">mutation</span><span class="o">.</span><span class="n">parent</span><span class="p">],</span>
                <span class="p">)</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
    <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">AncestorsGenerator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manages the process of building ancestors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_data</span><span class="p">,</span>
        <span class="n">ancestor_data</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span> <span class="o">=</span> <span class="n">sample_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span> <span class="o">=</span> <span class="n">ancestor_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span>
            <span class="n">progress_monitor</span><span class="p">,</span> <span class="n">generate_ancestors</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span> <span class="o">=</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">num_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>
        <span class="k">if</span> <span class="n">engine</span> <span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using C AncestorBuilder implementation&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span> <span class="o">=</span> <span class="n">_tsinfer</span><span class="o">.</span><span class="n">AncestorBuilder</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">engine</span> <span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">PY_ENGINE</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using Python AncestorBuilder implementation&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span> <span class="o">=</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">AncestorBuilder</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown engine:</span><span class="si">{</span><span class="n">engine</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_positions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add all sites that are suitable for inference into the ancestor builder</span>
<span class="sd">        (and subsequent inference), unless they are held in the specified list of</span>
<span class="sd">        excluded site positions. Suitable sites have only 2 listed alleles, one of</span>
<span class="sd">        which is defined as the ancestral_state, and where at least two samples</span>
<span class="sd">        carry the derived allele and at least one sample carries the ancestral allele.</span>

<span class="sd">        Suitable sites will be added at the time given by site.time, unless</span>
<span class="sd">        site.time is  ``np.nan`` or ``tskit.UNKNOWN_TIME``. In the first case,</span>
<span class="sd">        the site will simply excluded as if it were in the list of</span>
<span class="sd">        ``excluded_positions``. In the second case, then the time associated with</span>
<span class="sd">        the site will be the frequency of the derived allele (i.e. the number</span>
<span class="sd">        of samples with the derived allele divided by the total number of samples</span>
<span class="sd">        with non-missing alleles).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude_positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exclude_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">exclude_positions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exclude_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exclude_positions must be a 1D array of numbers&quot;</span><span class="p">)</span>
        <span class="n">exclude_positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude_positions</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting addition of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span><span class="si">}</span><span class="s2"> sites&quot;</span><span class="p">)</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ga_add_sites&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span><span class="p">)</span>
        <span class="n">inference_site_id</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span><span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># If there&#39;s missing data the last allele is None</span>
            <span class="n">num_alleles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

            <span class="n">counts</span> <span class="o">=</span> <span class="n">allele_counts</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">)</span>
            <span class="n">use_site</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">site</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">site</span><span class="o">.</span><span class="n">position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_positions</span>
                <span class="ow">and</span> <span class="n">num_alleles</span> <span class="o">==</span> <span class="mi">2</span>  <span class="c1"># This will ensure that the derived state is &quot;1&quot;</span>
                <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="o">.</span><span class="n">derived</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="o">.</span><span class="n">known</span>
                <span class="ow">and</span> <span class="n">site</span><span class="o">.</span><span class="n">ancestral_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">use_site</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">time</span>
                <span class="k">if</span> <span class="n">tskit</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
                    <span class="c1"># Non-variable sites have no obvious freq-as-time values</span>
                    <span class="k">assert</span> <span class="n">counts</span><span class="o">.</span><span class="n">known</span> <span class="o">!=</span> <span class="n">counts</span><span class="o">.</span><span class="n">derived</span>
                    <span class="k">assert</span> <span class="n">counts</span><span class="o">.</span><span class="n">known</span> <span class="o">!=</span> <span class="n">counts</span><span class="o">.</span><span class="n">ancestral</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">derived</span> <span class="o">/</span> <span class="n">counts</span><span class="o">.</span><span class="n">known</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
                    <span class="n">use_site</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Site with meaningless time value: skip inference</span>
            <span class="k">if</span> <span class="n">use_site</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">)</span>
                <span class="n">inference_site_id</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">set_inference_sites</span><span class="p">(</span><span class="n">inference_site_id</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished adding sites&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_run_synchronous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span><span class="p">:</span>
            <span class="n">before</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span><span class="o">.</span><span class="n">make_ancestor</span><span class="p">(</span><span class="n">focal_sites</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">before</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Made ancestor in </span><span class="si">{:.2f}</span><span class="s2">s at timepoint </span><span class="si">{}</span><span class="s2"> (epoch </span><span class="si">{}</span><span class="s2">) &quot;</span>
                <span class="s2">&quot;from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> (len=</span><span class="si">{}</span><span class="s2">) with </span><span class="si">{}</span><span class="s2"> focal sites (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">duration</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="p">[</span><span class="n">t</span><span class="p">],</span>
                    <span class="n">start</span><span class="p">,</span>
                    <span class="n">end</span><span class="p">,</span>
                    <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
                    <span class="n">focal_sites</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">focal_sites</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                <span class="n">focal_sites</span><span class="o">=</span><span class="n">focal_sites</span><span class="p">,</span>
                <span class="n">haplotype</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_run_threaded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress</span><span class="p">):</span>
        <span class="c1"># This works by pushing the ancestor descriptors onto the build_queue,</span>
        <span class="c1"># which the worker threads pop off and process. We need to add ancestors</span>
        <span class="c1"># in the the ancestor_data object in the correct order, so we maintain</span>
        <span class="c1"># a priority queue (add_queue) which allows us to track the next smallest</span>
        <span class="c1"># index of the generated ancestor. We add build ancestors to this queue</span>
        <span class="c1"># as they are built, and drain it when we can.</span>
        <span class="n">queue_depth</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span>  <span class="c1"># Seems like a reasonable limit</span>
        <span class="n">build_queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">queue_depth</span><span class="p">)</span>
        <span class="n">add_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="n">next_add_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">add_queue</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">drain_add_queue</span><span class="p">():</span>
            <span class="k">nonlocal</span> <span class="n">next_add_index</span>
            <span class="n">num_drained</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">add_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">add_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">next_add_index</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">haplotype</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">add_queue</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="o">=</span><span class="n">focal_sites</span><span class="p">,</span> <span class="n">haplotype</span><span class="o">=</span><span class="n">haplotype</span>
                <span class="p">)</span>
                <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="n">next_add_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">num_drained</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Drained </span><span class="si">{</span><span class="n">num_drained</span><span class="si">}</span><span class="s2"> ancestors from add queue&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">build_worker</span><span class="p">(</span><span class="n">thread_index</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">work</span> <span class="o">=</span> <span class="n">build_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">work</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span> <span class="o">=</span> <span class="n">work</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span><span class="o">.</span><span class="n">make_ancestor</span><span class="p">(</span><span class="n">focal_sites</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">add_lock</span><span class="p">:</span>
                    <span class="n">haplotype</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span>
                        <span class="n">add_queue</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">haplotype</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">drain_add_queue</span><span class="p">()</span>
                <span class="n">build_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="n">build_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

        <span class="n">build_threads</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">threads</span><span class="o">.</span><span class="n">queue_consumer_thread</span><span class="p">(</span>
                <span class="n">build_worker</span><span class="p">,</span> <span class="n">build_queue</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;build-worker-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">j</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Started </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="si">}</span><span class="s2"> build worker threads&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span><span class="p">):</span>
            <span class="n">build_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="p">))</span>

        <span class="c1"># Stop the the worker threads.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">build_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">build_threads</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">drain_add_queue</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span><span class="o">.</span><span class="n">ancestor_descriptors</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span><span class="p">)</span>
        <span class="c1"># Maps epoch numbers to their corresponding ancestor times.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting build for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="si">}</span><span class="s2"> ancestors&quot;</span><span class="p">)</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ga_generate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="n">root_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">av_timestep</span> <span class="o">=</span> <span class="n">root_time</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="p">)</span>
            <span class="n">root_time</span> <span class="o">+=</span> <span class="n">av_timestep</span>  <span class="c1"># Add a root a bit older than the oldest ancestor</span>
            <span class="c1"># Add an extra ancestor to act as a type of &quot;virtual root&quot; for the matching</span>
            <span class="c1"># algorithm: rather an awkward hack, but also allows the ancestor IDs to</span>
            <span class="c1"># line up. It&#39;s normally removed when processing the final tree sequence.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">root_time</span> <span class="o">+</span> <span class="n">av_timestep</span><span class="p">,</span>
                <span class="n">focal_sites</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">haplotype</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># This is the the &quot;grand MRCA&quot; of all zeros</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">root_time</span><span class="p">,</span>
                <span class="n">focal_sites</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">haplotype</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_run_synchronous</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_run_threaded</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished building ancestors&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Matcher</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A matching instance, used in both ``tsinfer.match_ancestors`` and</span>
<span class="sd">    ``tsinfer.match_samples``. For details of the ``path_compression``,</span>
<span class="sd">    `recombination_rate`` and ``mismatch_ratio`` parameters, see</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`.</span>

<span class="sd">    Note that the ``recombination`` and ``mismatch`` parameters can be used in</span>
<span class="sd">    ``match_ancestors`` and ``match_samples`` and are passed directly to this</span>
<span class="sd">    function, but are deliberately not publicly documented in those methods.</span>
<span class="sd">    They are expected to be numpy arrays of length ``num_inference_sites - 1`` and</span>
<span class="sd">    ``num_inference_sites`` respectively, containing values between 0 and 1, and</span>
<span class="sd">    allow recombination and mismatch probabilities to be set directly. The</span>
<span class="sd">    ``recombination`` probabilities measure the probability of a recombination event</span>
<span class="sd">    between adjacent inference sites, used to calculate the HMM transition probabilities</span>
<span class="sd">    in the L&amp;S-like matching algorithm. The ``mismatch`` probabilities are used</span>
<span class="sd">    to calculate the emission probabilities in the HMM. Note that values &gt; 0.5 in</span>
<span class="sd">    the recombination and (particularly) the mutation arrays are likely to lead to</span>
<span class="sd">    pathological behaviour  - for example, a mismatch probability of 1 means that a</span>
<span class="sd">    mismatch is *required* at every site. For this reason, the probabilities</span>
<span class="sd">    created for recombination and mismatch when using the the public-facing</span>
<span class="sd">    ``recombination_rate`` and ``mismatch_ratio`` parameters are never &gt; 0.5.</span>
<span class="sd">    TODO: include deliberately non-public details of precision here.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_data</span><span class="p">,</span>
        <span class="n">inference_site_position</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span> <span class="o">=</span> <span class="n">sample_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_compression</span> <span class="o">=</span> <span class="n">path_compression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inference_site_position</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No sites used for inference&quot;</span><span class="p">)</span>
        <span class="n">num_intervals</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Allocated by subclass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extended_checks</span> <span class="o">=</span> <span class="n">extended_checks</span>

        <span class="n">all_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">all_sites</span><span class="p">,</span> <span class="n">inference_site_position</span><span class="p">)</span>
        <span class="n">num_alleles</span> <span class="o">=</span> <span class="n">sample_data</span><span class="o">.</span><span class="n">num_alleles</span><span class="p">()[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">all_sites</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">inference_site_position</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Site positions for inference must be a subset of those in &quot;</span>
                <span class="s2">&quot;the sample data file.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1"># Map of site index to tree sequence position. Bracketing</span>
        <span class="c1"># values of 0 and L are used for simplicity.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">inference_site_position</span><span class="p">,</span> <span class="p">[</span><span class="n">sample_data</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recombination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>  <span class="c1"># TODO: reduce len by 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">recombination</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mismatch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">recombination</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mismatch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Directly setting probabilities requires specifying &quot;</span>
                    <span class="s2">&quot;both &#39;recombination&#39; and &#39;mismatch&#39;&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mismatch_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot simultaneously specify recombination &amp; recombination_rate, &quot;</span>
                    <span class="s2">&quot;or mismatch and mismatch_ratio&quot;</span>
                <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Recombination and mismatch probabilities given by user&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Must set recombination and mismatch arrays</span>
            <span class="k">if</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mismatch_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use mismatch without setting recombination&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mismatch_ratio</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">)</span> <span class="ow">or</span> <span class="n">num_intervals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Special case: revert to tsinfer 0.1 behaviour with no mismatch allowed</span>
                <span class="n">default_recombination_prob</span> <span class="o">=</span> <span class="mf">1e-2</span>
                <span class="n">default_mismatch_prob</span> <span class="o">=</span> <span class="mf">1e-20</span>  <span class="c1"># Substantially &lt; the value above</span>
                <span class="n">recombination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_intervals</span><span class="p">,</span> <span class="n">default_recombination_prob</span><span class="p">)</span>
                <span class="n">mismatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">default_mismatch_prob</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Mismatch prevented by setting constant high recombination and &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;low mismatch probabilities&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">genetic_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recombination_rate_to_dist</span><span class="p">(</span>
                    <span class="n">recombination_rate</span><span class="p">,</span> <span class="n">inference_site_position</span>
                <span class="p">)</span>
                <span class="n">recombination</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recombination_dist_to_prob</span><span class="p">(</span><span class="n">genetic_dists</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mismatch_ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">mismatch_ratio</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">mismatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mismatch_ratio_to_prob</span><span class="p">(</span>
                        <span class="n">mismatch_ratio</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">genetic_dists</span><span class="p">),</span> <span class="n">num_alleles</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Recombination and mismatch probabilities calculated from &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;specified recomb rates with mismatch ratio = </span><span class="si">{</span><span class="n">mismatch_ratio</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_intervals</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad length for recombination array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad length for mismatch array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">recombination</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">recombination</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Underlying recombination probabilities not between 0 &amp; 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mismatch</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mismatch</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Underlying mismatch probabilities not between 0 &amp; 1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="mi">13</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recombination</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recombination</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mismatch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fewer than two inference sites: no recombination possible&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Summary of recombination probabilities between sites: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;min=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;max=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;median=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;mean=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No inference sites: no mismatch possible&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Summary of mismatch probabilities over sites: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;min=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;max=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;median=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;mean=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Matching using </span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s2"> digits of precision in likelihood calcs&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">engine</span> <span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using C matcher implementation&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder_class</span> <span class="o">=</span> <span class="n">_tsinfer</span><span class="o">.</span><span class="n">TreeSequenceBuilder</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_matcher_class</span> <span class="o">=</span> <span class="n">_tsinfer</span><span class="o">.</span><span class="n">AncestorMatcher</span>
        <span class="k">elif</span> <span class="n">engine</span> <span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">PY_ENGINE</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using Python matcher implementation&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder_class</span> <span class="o">=</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">TreeSequenceBuilder</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_matcher_class</span> <span class="o">=</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">AncestorMatcher</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown engine:</span><span class="si">{</span><span class="n">engine</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Allocate 64K nodes and edges initially. This will double as needed and will</span>
        <span class="c1"># quickly be big enough even for very large instances.</span>
        <span class="n">max_edges</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="n">max_nodes</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">num_alleles</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot currently match with &gt; 2 alleles.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder_class</span><span class="p">(</span>
            <span class="n">num_alleles</span><span class="o">=</span><span class="n">num_alleles</span><span class="p">,</span> <span class="n">max_nodes</span><span class="o">=</span><span class="n">max_nodes</span><span class="p">,</span> <span class="n">max_edges</span><span class="o">=</span><span class="n">max_edges</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Allocated tree sequence builder with max_nodes=</span><span class="si">{</span><span class="n">max_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Allocate the matchers and statistics arrays.</span>
        <span class="n">num_threads</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span> <span class="o">=</span> <span class="n">ResultBuffer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_traceback_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_matches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matcher</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_matcher_class</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="p">,</span>
                <span class="n">recombination</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">recombination</span><span class="p">,</span>
                <span class="n">mismatch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">extended_checks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_checks</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">recombination_rate_to_dist</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mean number of recombinations between adjacent positions (i.e.</span>
<span class="sd">        the genetic distance in Morgans) given either a fixed rate or a RateMap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">get_cumulative_mass</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">recombination_dist_to_prob</span><span class="p">(</span><span class="n">genetic_distances</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert genetic distances (in Morgans) to a probability of recombination,</span>
<span class="sd">        (i.e. an odd number of events) assuming a Poisson distribution,</span>
<span class="sd">        see Haldane, 1919 J. Genetics 8: 299-309. This maxes out at 0.5 as dist -&gt; inf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">genetic_distances</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">mismatch_ratio_to_prob</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="n">genetic_distances</span><span class="p">,</span> <span class="n">num_alleles</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a mismatch ratio, relative to a genetic distance, to a probability</span>
<span class="sd">        of mismatch. A mismatch probability of 1 means that the emitted allele has a</span>
<span class="sd">        100% probability of being different from the allele implied by the hidden</span>
<span class="sd">        state. For all allele types to be emitted with equal probability, regardless</span>
<span class="sd">        of the copying haplotype, the mismatch probability should be set to</span>
<span class="sd">        1/num_alleles.</span>

<span class="sd">        For a small genetic_distance d, setting a ratio of X should give a</span>
<span class="sd">        probability of approximately X * r, where r is the recombination probability</span>
<span class="sd">        given by recombination_dist_to_prob(d)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">genetic_distances</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">num_alleles</span><span class="p">))</span> <span class="o">/</span> <span class="n">num_alleles</span>

    <span class="k">def</span> <span class="nf">_find_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child_id</span><span class="p">,</span> <span class="n">haplotype</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">thread_index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the path of the specified haplotype and upates the results</span>
<span class="sd">        for the specified thread_index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matcher</span><span class="p">[</span><span class="n">thread_index</span><span class="p">]</span>
        <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">[</span><span class="n">thread_index</span><span class="p">]</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">haplotype</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span>

        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">find_path</span><span class="p">(</span><span class="n">haplotype</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">set_path</span><span class="p">(</span><span class="n">child_id</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
        <span class="k">match</span><span class="p">[</span><span class="n">missing</span><span class="p">]</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span>
        <span class="n">diffs</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">haplotype</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="n">match</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">derived_state</span> <span class="o">=</span> <span class="n">haplotype</span><span class="p">[</span><span class="n">diffs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">set_mutations</span><span class="p">(</span><span class="n">child_id</span><span class="p">,</span> <span class="n">diffs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">derived_state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_traceback_size</span><span class="p">[</span><span class="n">thread_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">mean_traceback_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_matches</span><span class="p">[</span><span class="n">thread_index</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Matched node </span><span class="si">{}</span><span class="s2"> against </span><span class="si">{}</span><span class="s2"> available;&quot;</span>
            <span class="s2">&quot;num_edges=</span><span class="si">{}</span><span class="s2"> tb_size=</span><span class="si">{:.2f}</span><span class="s2"> match_mem=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">child_id</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_match_nodes</span><span class="p">,</span>
                <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">matcher</span><span class="o">.</span><span class="n">mean_traceback_size</span><span class="p">,</span>
                <span class="n">humanize</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="n">matcher</span><span class="o">.</span><span class="n">total_memory</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_inference_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the mutations stored in the tree sequence builder into the output</span>
<span class="sd">        format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mut_site</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">derived_state</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">dump_mutations</span><span class="p">()</span>
        <span class="n">mutation_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_mutations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mut_site</span><span class="p">)</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;ms_full_mutations&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span><span class="p">):</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">_update_site_metadata</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_FULL</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">site_id</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                <span class="n">ancestral_state</span><span class="o">=</span><span class="n">site</span><span class="o">.</span><span class="n">ancestral_state</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">while</span> <span class="n">mutation_id</span> <span class="o">&lt;</span> <span class="n">num_mutations</span> <span class="ow">and</span> <span class="n">mut_site</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">site_id</span><span class="p">:</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                    <span class="n">site_id</span><span class="p">,</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">],</span>
                    <span class="n">derived_state</span><span class="o">=</span><span class="n">site</span><span class="o">.</span><span class="n">reorder_alleles</span><span class="p">()[</span><span class="n">derived_state</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]],</span>
                <span class="p">)</span>
                <span class="n">mutation_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">AncestorMatcher</span><span class="p">(</span><span class="n">Matcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_data</span><span class="p">,</span> <span class="n">ancestor_data</span><span class="p">,</span> <span class="n">time_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="n">ancestor_data</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span> <span class="o">=</span> <span class="n">ancestor_data</span>
        <span class="k">if</span> <span class="n">time_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_units</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TIME_UNITS_UNCALIBRATED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_units</span> <span class="o">=</span> <span class="n">time_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">num_ancestors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">[:]</span>

        <span class="c1"># Add nodes for all the ancestors so that the ancestor IDs are equal</span>
        <span class="c1"># to the node IDs.</span>
        <span class="k">for</span> <span class="n">ancestor_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">[</span><span class="n">ancestor_id</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">ancestors</span><span class="p">()</span>
        <span class="c1"># Consume the &quot;virtual root&quot; ancestor</span>
        <span class="n">virtual_root_ancestor</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">virtual_root_ancestor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># assert np.array_equal(a.haplotype, np.zeros(self.num_sites, dtype=np.int8))</span>
            <span class="c1"># Create a list of all ID ranges in each epoch.</span>
            <span class="n">breaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">breaks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">breaks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">epoch_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_slices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_epoch</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__epoch_info_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch_index</span><span class="p">):</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_slices</span><span class="p">[</span><span class="n">epoch_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">[</span><span class="n">start</span><span class="p">])),</span> <span class="p">(</span><span class="s2">&quot;nanc&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ancestor_find_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancestor</span><span class="p">,</span> <span class="n">thread_index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># NOTE we&#39;re no longer using the ancestor&#39;s focal sites as a way</span>
        <span class="c1"># of knowing where mutations happen but instead having a non-zero</span>
        <span class="c1"># mutation rate and letting the mismatches do the work. We might</span>
        <span class="c1"># want to have a version with a zero mutation rate.</span>
        <span class="n">haplotype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">start</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">end</span>
        <span class="k">assert</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">haplotype</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">haplotype</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">haplotype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_find_path</span><span class="p">(</span><span class="n">ancestor</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">haplotype</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">thread_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__start_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch_index</span><span class="p">):</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_slices</span><span class="p">[</span><span class="n">epoch_index</span><span class="p">]</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">[</span><span class="n">start</span><span class="p">])),</span> <span class="p">(</span><span class="s2">&quot;nanc&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">set_detail</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">freeze_indexes</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__complete_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch_index</span><span class="p">):</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_slices</span><span class="p">[</span><span class="n">epoch_index</span><span class="p">])</span>
        <span class="n">num_ancestors_in_epoch</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="n">nodes_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_nodes</span>
        <span class="n">match_nodes_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_match_nodes</span>

        <span class="k">for</span> <span class="n">child_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">child_id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span>
                <span class="n">child_id</span><span class="p">,</span>
                <span class="n">left</span><span class="p">,</span>
                <span class="n">right</span><span class="p">,</span>
                <span class="n">parent</span><span class="p">,</span>
                <span class="n">compress</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path_compression</span><span class="p">,</span>
                <span class="n">extended_checks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_checks</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">site</span><span class="p">,</span> <span class="n">derived_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">get_mutations</span><span class="p">(</span><span class="n">child_id</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">add_mutations</span><span class="p">(</span><span class="n">child_id</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">derived_state</span><span class="p">)</span>

        <span class="n">extra_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="n">nodes_before</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_match_nodes</span>
            <span class="o">==</span> <span class="n">match_nodes_before</span> <span class="o">+</span> <span class="n">extra_nodes</span> <span class="o">+</span> <span class="n">num_ancestors_in_epoch</span>
        <span class="p">)</span>
        <span class="n">mean_memory</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">matcher</span><span class="o">.</span><span class="n">total_memory</span> <span class="k">for</span> <span class="n">matcher</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matcher</span><span class="p">])</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Finished epoch t=</span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2"> ancestors; </span><span class="si">{}</span><span class="s2"> extra nodes inserted; &quot;</span>
            <span class="s2">&quot;mean_tb_size=</span><span class="si">{:.2f}</span><span class="s2"> edges=</span><span class="si">{}</span><span class="s2">; mean_matcher_mem=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">current_time</span><span class="p">,</span>
                <span class="n">num_ancestors_in_epoch</span><span class="p">,</span>
                <span class="n">extra_nodes</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_traceback_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_matches</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,</span>
                <span class="n">humanize</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="n">mean_memory</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_traceback_size</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_matches</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__match_ancestors_single_threaded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_epoch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__start_epoch</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_slices</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ancestor_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">ancestor_id</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">id</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ancestor_find_path</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__complete_epoch</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__match_ancestors_multi_threaded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_epoch</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># See note on match samples multithreaded below. Should combine these</span>
        <span class="c1"># into a single function. Possibly when trying to make the thread</span>
        <span class="c1"># error handling more robust.</span>
        <span class="n">queue_depth</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span>  <span class="c1"># Seems like a reasonable limit</span>
        <span class="n">match_queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">queue_depth</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">match_worker</span><span class="p">(</span><span class="n">thread_index</span><span class="p">):</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">work</span> <span class="o">=</span> <span class="n">match_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">work</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__ancestor_find_path</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">thread_index</span><span class="p">)</span>
                <span class="n">match_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="n">match_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

        <span class="n">match_threads</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">threads</span><span class="o">.</span><span class="n">queue_consumer_thread</span><span class="p">(</span>
                <span class="n">match_worker</span><span class="p">,</span> <span class="n">match_queue</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;match-worker-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">j</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Started </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="si">}</span><span class="s2"> match worker threads&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_epoch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__start_epoch</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">epoch_slices</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ancestor_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">ancestor_id</span>
                <span class="n">match_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="c1"># Block until all matches have completed.</span>
            <span class="n">match_queue</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__complete_epoch</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="c1"># Stop the the worker threads.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">match_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">match_threads</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">match_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting ancestor matching for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="si">}</span><span class="s2"> epochs&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ma_match&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__match_ancestors_single_threaded</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__match_ancestors_multi_threaded</span><span class="p">()</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_output</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished ancestor matching&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span> <span class="nf">get_ancestors_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ancestors tree sequence tables. Only inference sites are included in</span>
<span class="sd">        this tree sequence. All nodes have the sample flag bit set, and if a node</span>
<span class="sd">        corresponds to an ancestor in the ancestors file, it is indicated via metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Building ancestors tree sequence&quot;</span><span class="p">)</span>
        <span class="n">tsb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span>

        <span class="n">tables</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span>
            <span class="n">sequence_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="p">)</span>

        <span class="n">flags</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_nodes</span><span class="p">()</span>
        <span class="n">pc_ancestors</span> <span class="o">=</span> <span class="n">is_pc_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>

        <span class="c1"># # FIXME we should do this as a struct codec?</span>
        <span class="c1"># dict_schema = permissive_json_schema()</span>
        <span class="c1"># dict_schema = add_to_schema(dict_schema, &quot;ancestor_data_id&quot;,</span>
        <span class="c1">#         {&quot;type&quot;: &quot;integer&quot;})</span>
        <span class="c1"># schema = tskit.MetadataSchema(dict_schema)</span>
        <span class="c1"># tables.nodes.schema = schema</span>

        <span class="c1"># Add metadata for any non-PC node, pointing to the original ancestor</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ancestor</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">is_pc</span> <span class="ow">in</span> <span class="n">pc_ancestors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_pc</span><span class="p">:</span>
                <span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_encode_raw_metadata</span><span class="p">({</span><span class="s2">&quot;ancestor_data_id&quot;</span><span class="p">:</span> <span class="n">ancestor</span><span class="p">}))</span>
                <span class="n">ancestor</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">packset_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_edges</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="n">left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">left</span><span class="p">],</span>
            <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">right</span><span class="p">],</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">convert_inference_mutations</span><span class="p">(</span><span class="n">tables</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting ancestors tree sequence&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># Note: it&#39;s probably possible to compute the mutation parents from the</span>
        <span class="c1"># tsb data structures but we&#39;re not doing it for now.</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">build_index</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">compute_mutation_parents</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting ancestors tree sequence done&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Built ancestors tree sequence: </span><span class="si">{}</span><span class="s2"> nodes (</span><span class="si">{}</span><span class="s2"> pc ancestors); </span><span class="si">{}</span><span class="s2"> edges; &quot;</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> sites; </span><span class="si">{}</span><span class="s2"> mutations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pc_ancestors</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span>

    <span class="k">def</span> <span class="nf">store_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ancestors_tables</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Allocate an empty tree sequence.</span>
            <span class="n">tables</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span>
                <span class="n">sequence_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">sequence_length</span>
            <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">time_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_units</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">SampleMatcher</span><span class="p">(</span><span class="n">Matcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_data</span><span class="p">,</span> <span class="n">ancestors_ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span> <span class="o">=</span> <span class="n">ancestors_ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sample_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">restore_tree_sequence_builder</span><span class="p">()</span>
        <span class="c1"># Map from input sample indexes (IDs in the SampleData file) to the</span>
        <span class="c1"># node ID in the tree sequence.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">restore_tree_sequence_builder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Ancestors tree sequence not compatible: sequence length is different to&quot;</span>
                <span class="s2">&quot; sample data file.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All nodes must have time &gt; 0&quot;</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">edges</span>
        <span class="c1"># Get the indexes into the position array.</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">!=</span> <span class="n">edges</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid left coordinates&quot;</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">!=</span> <span class="n">edges</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid right coordinates&quot;</span><span class="p">)</span>

        <span class="c1"># Need to sort by child ID here and left so that we can efficiently</span>
        <span class="c1"># insert the child paths.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">child</span><span class="p">))</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">restore_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">nodes</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">restore_edges</span><span class="p">(</span>
            <span class="n">left</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">right</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_match_nodes</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">mutations</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span>
        <span class="n">derived_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mutations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">mutation_site</span> <span class="o">=</span> <span class="n">mutations</span><span class="o">.</span><span class="n">site</span>
        <span class="n">site_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mutation_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span><span class="p">):</span>
            <span class="k">while</span> <span class="p">(</span>
                <span class="n">mutation_id</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">mutations</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mutation_site</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">site_id</span>
            <span class="p">):</span>
                <span class="n">allele</span> <span class="o">=</span> <span class="n">mutations</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span><span class="o">.</span><span class="n">derived_state</span>
                <span class="n">derived_state</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">reorder_alleles</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">allele</span><span class="p">)</span>
                <span class="n">mutation_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">site_id</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">restore_mutations</span><span class="p">(</span>
            <span class="n">mutation_site</span><span class="p">,</span> <span class="n">mutations</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">derived_state</span><span class="p">,</span> <span class="n">mutations</span><span class="o">.</span><span class="n">parent</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Loaded </span><span class="si">{}</span><span class="s2"> samples </span><span class="si">{}</span><span class="s2"> nodes; </span><span class="si">{}</span><span class="s2"> edges; </span><span class="si">{}</span><span class="s2"> sites; </span><span class="si">{}</span><span class="s2"> mutations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">mutations</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__process_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_id</span><span class="p">,</span> <span class="n">haplotype</span><span class="p">,</span> <span class="n">thread_index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_find_path</span><span class="p">(</span><span class="n">sample_id</span><span class="p">,</span> <span class="n">haplotype</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">thread_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__match_samples_single_threaded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
        <span class="n">sample_haplotypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">haplotypes</span><span class="p">(</span>
            <span class="n">indexes</span><span class="p">,</span>
            <span class="n">sites</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span><span class="p">,</span>
            <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">sample_haplotypes</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__process_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__match_samples_multi_threaded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
        <span class="c1"># Note that this function is not almost identical to the match_ancestors</span>
        <span class="c1"># multithreaded function above. All we need to do is provide a function</span>
        <span class="c1"># to do the matching and some producer for the actual items and we</span>
        <span class="c1"># can bring this into a single function.</span>

        <span class="n">queue_depth</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span>  <span class="c1"># Seems like a reasonable limit</span>
        <span class="n">match_queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">queue_depth</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">match_worker</span><span class="p">(</span><span class="n">thread_index</span><span class="p">):</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">work</span> <span class="o">=</span> <span class="n">match_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">work</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">sample_id</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">work</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__process_sample</span><span class="p">(</span><span class="n">sample_id</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">thread_index</span><span class="p">)</span>
                <span class="n">match_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="n">match_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

        <span class="n">match_threads</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">threads</span><span class="o">.</span><span class="n">queue_consumer_thread</span><span class="p">(</span>
                <span class="n">match_worker</span><span class="p">,</span> <span class="n">match_queue</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;match-worker-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">j</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Started </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="si">}</span><span class="s2"> match worker threads&quot;</span><span class="p">)</span>

        <span class="n">sample_haplotypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">haplotypes</span><span class="p">(</span>
            <span class="n">indexes</span><span class="p">,</span>
            <span class="n">sites</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span><span class="p">,</span>
            <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">sample_haplotypes</span><span class="p">:</span>
            <span class="n">match_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">))</span>

        <span class="c1"># Stop the the worker threads.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">match_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">match_threads</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">match_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_indexes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">):</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">flags</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">dump_nodes</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Started matching for </span><span class="si">{</span><span class="n">num_samples</span><span class="si">}</span><span class="s2"> samples&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ms_match&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__match_samples_single_threaded</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__match_samples_multi_threaded</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Inserting sample paths: </span><span class="si">{}</span><span class="s2"> edges in total&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">total_edges</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">progress_monitor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ms_paths&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sample_indexes</span><span class="p">:</span>
                <span class="n">node_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">times</span><span class="p">[</span><span class="n">parent</span><span class="p">]):</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">parent</span><span class="p">])]</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Failed to put sample </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> (node </span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="s2">) at time &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">times</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="si">}</span><span class="s2"> as it has a younger parent (node </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">).&quot;</span>
                    <span class="p">)</span>
                <span class="n">builder</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span>
                    <span class="n">node_id</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path_compression</span>
                <span class="p">)</span>
                <span class="n">site</span><span class="p">,</span> <span class="n">derived_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">get_mutations</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span>
                <span class="n">builder</span><span class="o">.</span><span class="n">add_mutations</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">derived_state</span><span class="p">)</span>
                <span class="n">progress_monitor</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">progress_monitor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finalising tree sequence&quot;</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_samples_tree_sequence</span><span class="p">()</span>
        <span class="c1"># Check that there are the same number of samples as expected</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="p">)</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span> <span class="nf">get_samples_tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_additional_sites</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current state of the build tree sequence. Sample nodes will have the</span>
<span class="sd">        sample node flag set and be in the same order as passed the order of</span>
<span class="sd">        sample_indexes passed to match_samples. For correct sample reconstruction,</span>
<span class="sd">        the non-inference sites also need to be placed into the resulting tree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tsb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">metadata</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">populations_metadata_schema</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">metadata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">populations_metadata</span><span class="p">[:]:</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Use the default json encoding to avoid breaking old code.</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">individuals_metadata_schema</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="n">add_to_schema</span><span class="p">(</span>
                <span class="n">schema</span><span class="p">,</span>
                <span class="s2">&quot;sample_data_time&quot;</span><span class="p">,</span>
                <span class="n">definition</span><span class="o">=</span><span class="n">sample_data_time_metadata_definition</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>

        <span class="n">num_ancestral_individuals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">individuals</span><span class="p">():</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">metadata</span>
            <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;sample_data_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">time</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">ind</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">location</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding tree sequence nodes&quot;</span><span class="p">)</span>
        <span class="n">flags</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_nodes</span><span class="p">()</span>
        <span class="n">num_pc_ancestors</span> <span class="o">=</span> <span class="n">count_pc_ancestors</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># All true ancestors are samples in the ancestors tree sequence. We unset</span>
        <span class="c1"># the SAMPLE flag but keep other flags intact.</span>
        <span class="n">new_flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span> <span class="o">~</span><span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">new_flags</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">sample_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="n">sample_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">individuals_population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">individuals_population</span><span class="p">[:]</span>
        <span class="n">samples_individual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:]</span>
        <span class="n">individuals_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">sample_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">individual</span> <span class="o">=</span> <span class="n">samples_individual</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">individuals_time</span><span class="p">[</span><span class="n">individual</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flags</span><span class="p">[</span><span class="n">sample_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span>
                    <span class="n">flags</span><span class="p">[</span><span class="n">sample_id</span><span class="p">],</span> <span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_HISTORICAL_SAMPLE</span>
                <span class="p">)</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">individuals_population</span><span class="p">[</span><span class="n">individual</span><span class="p">]</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">[</span><span class="n">sample_id</span><span class="p">],</span>
                <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="n">sample_id</span><span class="p">],</span>
                <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                <span class="n">individual</span><span class="o">=</span><span class="n">num_ancestral_individuals</span> <span class="o">+</span> <span class="n">individual</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Add in the remaining non-sample nodes.</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tsb</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">):</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding tree sequence edges&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># We have no inference sites, so no edges have been estimated. To ensure</span>
            <span class="c1"># we have a rooted tree, we add in edges for each sample to an artificial</span>
            <span class="c1"># root.</span>
            <span class="k">assert</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">max_node_time</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">max_node_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ultimate</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">max_node_time</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">ultimate</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sample_id</span> <span class="ow">in</span> <span class="n">sample_ids</span><span class="p">:</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">sample_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">left</span><span class="p">],</span>
                <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">right</span><span class="p">],</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting and building intermediate tree sequence.&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">sites_metadata_schema</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="n">add_to_schema</span><span class="p">(</span>
                <span class="n">schema</span><span class="p">,</span>
                <span class="s2">&quot;inference_type&quot;</span><span class="p">,</span>
                <span class="n">definition</span><span class="o">=</span><span class="n">inference_type_metadata_definition</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_inference_mutations</span><span class="p">(</span><span class="n">tables</span><span class="p">)</span>

        <span class="c1"># FIXME this is a shortcut. We should be computing the mutation parent above</span>
        <span class="c1"># during insertion (probably)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">build_index</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">compute_mutation_parents</span><span class="p">()</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Built samples tree sequence: </span><span class="si">{}</span><span class="s2"> nodes (</span><span class="si">{}</span><span class="s2"> pc); </span><span class="si">{}</span><span class="s2"> edges; &quot;</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> sites; </span><span class="si">{}</span><span class="s2"> mutations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
                <span class="n">num_pc_ancestors</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
        <span class="n">num_additional_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span>
        <span class="k">if</span> <span class="n">map_additional_sites</span> <span class="ow">and</span> <span class="n">num_additional_sites</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Mapping additional sites&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">samples</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">insert_missing_sites</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_data</span><span class="p">,</span>
                <span class="n">ts</span><span class="p">,</span>
                <span class="n">sample_id_map</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())),</span>
                <span class="n">progress_monitor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping additional site mapping&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span> <span class="nf">get_augmented_ancestors_tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_indexes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ancestors tree sequence augmented with samples as extra ancestors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Building augmented ancestors tree sequence&quot;</span><span class="p">)</span>
        <span class="n">tsb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">flags</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_nodes</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_pc_ancestors</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">flags</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">times</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="c1"># This is an augmented ancestor node.</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                    <span class="n">flags</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE_ANCESTOR</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">_encode_raw_metadata</span><span class="p">(</span>
                        <span class="p">{</span><span class="s2">&quot;sample_data_id&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">[</span><span class="n">s</span><span class="p">])}</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This is a path compressed node</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">is_pc_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">num_pc_ancestors</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">s</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># Increment the time for all nodes so the augmented samples are no longer</span>
        <span class="c1"># at timepoint 0.</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># TODO - check this works for augmented ancestors with missing data</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_edges</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="n">left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">left</span><span class="p">],</span>
            <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">right</span><span class="p">],</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_inference_mutations</span><span class="p">(</span><span class="n">tables</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting ancestors tree sequence&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting ancestors tree sequence done&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Augmented ancestors tree sequence: </span><span class="si">{}</span><span class="s2"> nodes (</span><span class="si">{}</span><span class="s2"> extra pc ancestors); &quot;</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> edges; </span><span class="si">{}</span><span class="s2"> sites; </span><span class="si">{}</span><span class="s2"> mutations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
                <span class="n">num_pc_ancestors</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">ResultBuffer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper for numpy arrays representing the results of a copying operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_edges</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears this result buffer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_edges</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">set_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">node_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_edges</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">derived_state</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">site</span><span class="p">,</span> <span class="n">derived_state</span>

    <span class="k">def</span> <span class="nf">get_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">has_single_edge_over_grand_root</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="c1"># Internal function to check if this is a &quot;raw&quot; inferred tree sequence.</span>
    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_edges</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># must have edge to grand root and above grand root</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">last_edge</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Not a single edge spanning the entire genome</span>
    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="o">==</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># other edges point to the oldest node =&gt; not a virtual-like root</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">has_same_root_everywhere</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">trees</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">has_single_root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="post_process"><a class="viewcode-back" href="../../api.html#tsinfer.post_process">[docs]</a><span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">split_mrca</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">erase_flanks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1"># Parameters below deliberately undocumented</span>
    <span class="n">warn_if_unexpected_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">simplify_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    post_process(ts, *, split_mrca=None, erase_flanks=None)</span>

<span class="sd">    Post-process a tsinferred tree sequence into a more conventional form. This is</span>
<span class="sd">    the function run by default on the final tree sequence output by</span>
<span class="sd">    :func:`match_samples`. It involves the following 4 steps:</span>

<span class="sd">    #. If the oldest node is connected to a single child via an edge that spans the</span>
<span class="sd">       entire tree sequence, this oldest node is removed, so that its child becomes</span>
<span class="sd">       the new root (this step is undertaken to remove the &quot;virtual-root-like node&quot;</span>
<span class="sd">       which is added to ancestor tree sequences to enable matching).</span>
<span class="sd">    #. If the oldest node is removed in the first step and the new root spans the</span>
<span class="sd">       entire genome, it is treated as the &quot;grand MRCA&quot; and (unless split_mrca is</span>
<span class="sd">       ``False``) the node is split into multiple coexisiting nodes with the splits</span>
<span class="sd">       occurring whenever the children of the grand MRCA change. The rationale</span>
<span class="sd">       is that tsinfer creates a grand MRCA consisting of a single ancestral haplotype</span>
<span class="sd">       with all inference sites in the ancestral state: this is, however, unlikely</span>
<span class="sd">       to represent a single ancestor in the past. If nodes in the tree sequence are</span>
<span class="sd">       then dated, these MRCA nodes can be pushed to different times.</span>
<span class="sd">    #. Often, extensive regions of genome exist before the first defined site and after</span>
<span class="sd">       the last defined site. Since no data exists in these sections of the genome, post</span>
<span class="sd">       processing by default erases the inferred topology in these regions. However,</span>
<span class="sd">       if ``erase_flanks`` is False, the flanking regions at the start and end will be</span>
<span class="sd">       assigned the same topology as inferred at the first and last site respectively.</span>
<span class="sd">    #. The sample nodes are reordered such that they are the first nodes listed in the</span>
<span class="sd">       node table,  removing tree nodes and edges that are not on a path between the</span>
<span class="sd">       root and any of the samples (by applying the :meth:`~tskit.TreeSequence.simplify`</span>
<span class="sd">       method with ``keep_unary`` set to True but ``filter_sites``,</span>
<span class="sd">       ``filter_populations`` and ``filter_individuals`` set to False).</span>

<span class="sd">    :param bool split_mrca: If ``True`` (default) and the oldest node is the only</span>
<span class="sd">        parent to a single &quot;grand MRCA&quot;, split the grand MRCA into separate nodes</span>
<span class="sd">        (see above). If ``False`` do not attempt to identify or split a grand MRCA.</span>
<span class="sd">    :param bool erase_flanks: If ``True`` (default), keep only the</span>
<span class="sd">        inferred topology between the first and last sites. If ``False``,</span>
<span class="sd">        output regions of topology inferred before the first site and after</span>
<span class="sd">        the last site.</span>
<span class="sd">    :return: The post-processed tree sequence.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">split_mrca</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">split_mrca</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">erase_flanks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">erase_flanks</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">simplify_only</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">has_single_edge_over_grand_root</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Removing the oldest edge to detach the virtual-root-like ancestor&quot;</span>
            <span class="p">)</span>
            <span class="n">last_edge</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Edge with oldest parent is last in the edge table</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># move any mutations above the virtual-root-like ancestor to above the grand</span>
            <span class="c1"># MRCA instead (these will be mutations placed by parsimony)</span>
            <span class="n">mutations_node</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">node</span>
            <span class="n">mutations_node</span><span class="p">[</span><span class="n">mutations_node</span> <span class="o">==</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">child</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">mutations_node</span>

            <span class="k">if</span> <span class="n">split_mrca</span><span class="p">:</span>
                <span class="n">split_grand_mrca</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="n">warn_if_unexpected_format</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">warn_if_unexpected_format</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Cannot find a virtual-root-like ancestor during preprocessing&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">erase_flanks</span> <span class="ow">and</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># So that the last site falls within a tree, we must add one to the</span>
            <span class="c1"># site position (or simply extend to the end of the ts)</span>
            <span class="n">keep_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">keep_intervals</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">ts</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">keep_max</span><span class="p">]],</span>
                <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">erased</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">-</span> <span class="n">keep_max</span>
            <span class="n">erased</span> <span class="o">*=</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Erased flanks covering </span><span class="si">{</span><span class="n">erased</span><span class="si">}</span><span class="s2">% of the genome: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> units at the start and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">-</span> <span class="n">keep_max</span><span class="si">}</span><span class="s2"> units at the end&quot;</span>
            <span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Simplifying with filter_sites=False, filter_populations=False, &quot;</span>
        <span class="s2">&quot;filter_individuals=False, and keep_unary=True on &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">num_rows</span><span class="si">}</span><span class="s2"> nodes and </span><span class="si">{</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">num_rows</span><span class="si">}</span><span class="s2"> edges&quot;</span>
    <span class="p">)</span>
    <span class="c1"># NB: if this is an inferred TS, match_samples is guaranteed to produce samples</span>
    <span class="c1"># in the same order as passed in to sample_indexes, and simplification will</span>
    <span class="c1"># simply stick all those at the start but keep their order the same</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
        <span class="n">filter_sites</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_populations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_individuals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_unary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Finished simplify; now have </span><span class="si">{}</span><span class="s2"> nodes and </span><span class="si">{}</span><span class="s2"> edges&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">num_rows</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">_post_process</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">post_process</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">split_grand_mrca</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="n">warn_if_unexpected_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Internal function: if a single oldest node is a root across the entire genome,</span>
    <span class="c1"># split it up into a set of contemporaneous nodes whenever the node children change</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">has_same_root_everywhere</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">warn_if_unexpected_format</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot find a single contiguous grand MRCA to split&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Split into multiple contemporaneous nodes whenever the node children change</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Splitting the all zeros grand MRCA into separate nodes&quot;</span><span class="p">)</span>
    <span class="n">genomewide_mrca_id</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span>
    <span class="n">genomewide_mrca</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">genomewide_mrca_id</span><span class="p">)</span>
    <span class="n">root_breaks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">edges</span>
    <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># the last edges are the ones connecting to the genomewide_mrca</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span> <span class="o">==</span> <span class="n">genomewide_mrca_id</span><span class="p">:</span>
        <span class="n">root_breaks</span> <span class="o">|=</span> <span class="p">{</span><span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">right</span><span class="p">}</span>
        <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">root_breaks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">root_breaks</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">root_breaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">root_breaks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
        <span class="c1"># Only a single edge: no splitting needed</span>
        <span class="k">return</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Splitting grand MRCA into </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">root_breaks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="si">}</span><span class="s2"> separate nodes&quot;</span><span class="p">)</span>
    <span class="c1"># detach the grand_mrca from all its children: it will then get simplified out</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Move the mutations above the grand_mrca to the new nodes</span>
    <span class="n">mutation_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">genomewide_mrca_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mutation_positions</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">site</span><span class="p">[</span><span class="n">mutation_ids</span><span class="p">]]</span>
    <span class="n">mut_iter</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mutation_ids</span><span class="p">,</span> <span class="n">mutation_positions</span><span class="p">)</span>
    <span class="n">mutation_id</span><span class="p">,</span> <span class="n">mutation_pos</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">mut_iter</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">))</span>

    <span class="c1"># Go through the trees, making a new root node whereever we hit a root_break</span>
    <span class="c1"># and recreating the edges to the children each time</span>
    <span class="n">trees_iter</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">trees</span><span class="p">()</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees_iter</span><span class="p">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">root_breaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">root_breaks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">while</span> <span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees_iter</span><span class="p">)</span>
        <span class="n">new_root</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">genomewide_mrca</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">genomewide_mrca_id</span><span class="p">):</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">new_root</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">mutation_pos</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">node</span><span class="o">=</span><span class="n">new_root</span>
            <span class="p">)</span>
            <span class="n">mutation_id</span><span class="p">,</span> <span class="n">mutation_pos</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">mut_iter</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">))</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">right</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">minimise</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tree sequence with the minimal information required to represent</span>
<span class="sd">    the tree topologies at its sites.</span>

<span class="sd">    This is a convenience function used when we wish to use a subset of the</span>
<span class="sd">    sites in a tree sequence for ancestor matching. It is a thin-wrapper</span>
<span class="sd">    over the simplify method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
        <span class="n">reduce_to_site_topology</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_sites</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_individuals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_populations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Tskit Developers<br/>
  
      &copy; Copyright 2018.<br/>
    <div class="extra_footer">
      tsinfer undefined
    </div>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>